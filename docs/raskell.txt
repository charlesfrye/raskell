-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | RASP-L in Haskell
--   
--   Implements the RASP-L language from "What Algorithms Can Transformers
--   Learn" by Zhou et al. For more information, see the README at
--   <a>https://github.com/charlesfrye/raskell#readme</a>.
@package raskell
@version 0.0.0.1


-- | This module provides the core of the RASP-L language.
--   
--   It is based on Listing 2 of "What Algorithms Can Transformers Learn",
--   <a>https://arxiv.org/abs/2310.16028</a>, by Zhou et al.
module RaskellCore

-- | A <a>Token</a> in a <a>Sequence</a> is a small integer. RASP-L uses
--   <a>Int8</a> to ensure all maps of type <a>Token</a> -&gt; <a>Token</a>
--   are learnable.
type Token = Int8

-- | A <a>Sequence</a> is a list of <a>Token</a>s.
type Sequence = [Token]

-- | A collection of keys is a list of <a>Token</a>s.
type Keys = Sequence

-- | A collection of queries is a list of <a>Token</a>s.
type Queries = Sequence

-- | A collection of values is a list of <a>Token</a>s.
type Values = Sequence

-- | We can compare <a>Keys</a> and <a>Queries</a> to determine if they
--   match.
type Predicate = Token -> Token -> Bool

-- | The equivalents of "attention maps" are collections of <a>Bool</a>ean
--   sequences.
type Selector = [BoolSequence]

-- | Internally, we sometimes need to operate on collections of
--   <a>Bool</a>s.
type BoolSequence = [Bool]

-- | Type alias for "fully-specified" aggregators that are ready to
--   aggregate a sequence of values with a selector.
type Aggregator = Selector -> Values -> Sequence

-- | Enum for the three methods for aggregating selected values
data AggregationType
Min :: AggregationType
Mean :: AggregationType
Max :: AggregationType

-- | Performs a key-query-value lookup operation and aggregates over
--   values.
--   
--   Given a filler token, an aggregation type, two sequences (keys and
--   queries), and a predicate, it returns a processed sequence. It first
--   selects elements based on the predicate and then aggregates them.
--   
--   Roughly matches the attention layer of a Transformer.
kqv :: Token -> AggregationType -> Keys -> Queries -> Predicate -> Values -> Sequence

-- | Performs Key-Query-Value lookup with maximum aggregation of values.
maxKQV :: Keys -> Queries -> Predicate -> Values -> Sequence

-- | Performs Key-Query-Value lookup with minimum aggregation of values.
minKQV :: Keys -> Queries -> Predicate -> Values -> Sequence

-- | Compareis pairs of elements from sequences with a predicate subject to
--   a causal constraint.
selectCausal :: Keys -> Queries -> Predicate -> Selector

-- | Creates a matched-length constant sequence with the provided token.
filledWith :: Sequence -> Token -> Sequence

-- | Extracts the indices of the elements in a sequence.
indicesOf :: Sequence -> Sequence

-- | Aggregates values with some aggregation, filling in with a default
--   token.
aggregate :: AggregationType -> Token -> Aggregator

-- | Aggregates values by selecting the largest value.
aggrMax :: Token -> Aggregator

-- | Aggregates values by taking the mean.
aggrMean :: Token -> Aggregator

-- | Aggregates values by selecting the smallest value.
aggrMin :: Token -> Aggregator

-- | Computes the "width", or number of nonzero entries, of the rows of a
--   <a>Selector</a>.
selWidth :: Selector -> Sequence
fromBool :: Bool -> Token

-- | Applies an elementwise operation to a sequence of tokens.
--   
--   Roughly matches the MLP layer in a Transformer. Alias for <a>map</a>.
tokMap :: (Token -> Token) -> Sequence -> Sequence

-- | Applies an elementwise operation for pairs of tokens on a pair of
--   sequences. Alias for <a>zipWith</a>.
seqMap :: (Token -> Token -> Token) -> Sequence -> Sequence -> Sequence

-- | Creates a sequence of the same length as the provided sequence filled
--   with the provided token. Alias for <a>filledWith</a>.
full :: Sequence -> Token -> Sequence

-- | Extracts the indices of the elements in a sequence. Alias for
--   <a>indicesOf</a>.
indices :: Sequence -> Sequence

-- | Creates an aggregator with a given aggregation type. Alias for
--   <a>aggregate</a>.
aggr :: AggregationType -> Token -> Aggregator

-- | Produces a selector indicating which pairs of <a>Keys</a> and
--   <a>Queries</a> match.
select :: Bool -> Keys -> Queries -> Predicate -> Selector


-- | This module provides convenience functions built from the core of the
--   RASP-L language.
--   
--   It is based on Listing 3 of "What Algorithms Can Transformers Learn",
--   <a>https://arxiv.org/abs/2310.16028</a>, by Zhou et al.
module RaskellLib

-- | Use a boolean sequence to select between two sequences. Also known in
--   Python RASP-L as "where", see <a>where'</a>.
(?) :: [Bool] -> (Sequence, Sequence) -> Sequence

-- | Shift a sequence to the right by a given number of elements, filling
--   the vacated positions with the provided <a>Token</a>.
shiftRight :: Token -> Int8 -> Sequence -> Sequence

-- | Maps tokens onto bools using Python's "truthiness" rules.
toBool :: Token -> Bool

-- | Masks a <a>Sequence</a> with a boolean sequence, using the provided
--   <a>Token</a> as the mask.
mask :: Token -> [Bool] -> Sequence -> Sequence

-- | Computes the cumulative sum of a boolean sequence.
cumSum :: [Bool] -> Sequence

-- | Computes the running maximum of a <a>Sequence</a>.
maximum' :: Sequence -> Sequence

-- | Computes the running minimum of a <a>Sequence</a>.
minimum' :: Sequence -> Sequence

-- | Computes the indices of the running maximum values in a
--   <a>Sequence</a>.
argmax :: Sequence -> Sequence

-- | Computes the indices of the running minimum values in a
--   <a>Sequence</a>.
argmin :: Sequence -> Sequence
leq :: Token -> Token -> Bool
geq :: Token -> Token -> Bool
lt :: Token -> Token -> Bool
gt :: Token -> Token -> Bool

-- | Greedily and autoregressively sample the output of a RASP-L program on
--   a sequence.
sample :: Token -> (Sequence -> Sequence) -> Sequence -> Word8 -> Sequence

-- | Use a boolean sequence to select between two sequences. Provided for
--   compatibility with Listing 3, but with an apostrophe to avoid a name
--   clash with the "where" keyword.
where' :: [Bool] -> Sequence -> Sequence -> Sequence

-- | Greedily and autoregressively sample the output of a RASP-L program on
--   a sequence.
--   
--   Provided for compatibility with Listing 3.
sample_autoregressive :: Token -> (Sequence -> Sequence) -> Sequence -> Word8 -> Sequence
